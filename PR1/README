Практична робота 1

Програма була створена та скомпільована в середовищі Ubuntu Linux за допомогою компілятора gcc. Після виконання команди компіляції створюється виконуваний файл у форматі ELF (Executable and Linkable Format). 
На цьому етапі відбувається перетворення вихідного коду мовою C у машинний код, а також компонування з необхідними бібліотеками. Під час запуску програми командою ./program ядро Linux створює новий процес і 
виділяє для нього окремий віртуальний адресний простір. Кожен процес у Linux ізольований і не має прямого доступу до пам’яті інших процесів. Це забезпечує стабільність та безпеку системи. Після завантаження 
програми її пам’ять поділяється на кілька основних сегментів. Сегмент коду (text segment) містить машинні інструкції програми. Він зазвичай доступний тільки для читання та може спільно використовуватися кількома 
екземплярами однієї програми. Сегмент ініціалізованих даних (data segment) містить глобальні та статичні змінні, яким задано початкові значення. Цей сегмент завантажується в оперативну пам’ять під час запуску 
програми. Сегмент неініціалізованих даних (BSS) містить глобальні та статичні змінні без початкового значення. Для них пам’ять резервується під час запуску, але у виконуваному файлі вони не зберігаються у 
вигляді конкретних значень. Стек (stack) використовується для зберігання локальних змінних функцій, параметрів функцій та адрес повернення. Він працює за принципом «останнім прийшов — першим вийшов» (LIFO). 
При кожному виклику функції створюється новий кадр стеку, який автоматично видаляється після завершення функції. Купа (heap) призначена для динамічного виділення пам’яті під час виконання програми. Пам’ять 
у купі виділяється за допомогою функцій malloc, calloc або realloc, а звільняється функцією free. На відміну від стеку, керування купою здійснюється програмістом. Якщо пам’ять не звільнити, виникає витік пам’яті.
Операційна система Linux використовує механізм віртуальної пам’яті. Кожен процес працює з власним віртуальним адресним простором, який відображається на фізичну пам’ять за допомогою сторінкової адресації. 
Зазвичай розмір сторінки становить 4 КБ. За потреби може використовуватися область підкачки (swap). Такий підхід забезпечує ізоляцію процесів, захист пам’яті та ефективне використання ресурсів. Якщо програма 
використовує стандартні бібліотеки, наприклад математичну бібліотеку libm, вони підключаються динамічно під час запуску. Динамічний компонувальник завантажує відповідні файли .so у пам’ять. Один і той самий 
код бібліотеки може використовуватися кількома процесами, що зменшує споживання пам’яті. Після завершення роботи програми ядро Linux автоматично звільняє всю пам’ять, виділену процесу, закриває відкриті ресурси 
та видаляє процес із системи. Таким чином, у середовищі Ubuntu Linux взаємодія програми з пам’яттю відбувається через чітко структуровані сегменти (код, дані, стек, купа) та механізм віртуальної пам’яті, що 
забезпечує ефективність, безпеку та стабільність виконання програм.

Висновок:
У ході виконання роботи було досліджено, як програма мовою C взаємодіє з пам’яттю в операційній системі Ubuntu Linux. Встановлено, що після компіляції створюється виконуваний файл у форматі ELF, який під час 
запуску завантажується в окремий віртуальний адресний простір процесу. Пам’ять процесу має чітку структуру та поділяється на сегменти: код, ініціалізовані дані, неініціалізовані дані (BSS), стек і купу. Стек 
використовується для автоматичного зберігання локальних змінних і керування викликами функцій, тоді як купа призначена для динамічного виділення пам’яті під час виконання програми. Керування купою покладається 
на програміста. Механізм віртуальної пам’яті Linux забезпечує ізоляцію процесів, захист даних і ефективне використання ресурсів оперативної пам’яті. Таким чином, архітектура пам’яті в Linux створює надійне 
середовище для виконання програм і дозволяє ефективно керувати системними ресурсами.

